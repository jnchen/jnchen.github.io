---
layout: post
title: "正则表达式笔记"
description: "正则表达式笔记"
category: 笔记
tags: [regex, note]
date: 2015-09-02 12:06:37
---

# 正则表达式

## 简介

正则表达式和操作系统的通配符类似，是用来进行文本匹配的工具

元字符(metacharacter)是一类特殊的字符,有特殊的功能来匹配字符串

## 元字符

|代码|说明|
|-----|-----|
|`.`	|	匹配除了换行符之外的任意字符|
|`\w`	|	匹配字母或数字或下划线|
|`\s`	|	匹配任意空白字符|
|`\d`	|	匹配字母或数字|
|`\b`	|	匹配单词的开始或结束|
|`^`	|	匹配字符串的开始|
|`$`	|	匹配字符串的结束|

## 字符转义

如果想查找元字符本身,对元字符进行转义

在想要转义的元字符前加`\`恢复它本来的意义

## 重复字符

|代码/语法|说明|
|----|----|
|`*`|重复任意次(0~无穷)  元字符|
|`+`|重复一次或多次(>0)  元字符|
|`?`|重复0次或一次(有1次或没有)  元字符|
|{n}|重复n次(不能多不能少)|
|{n,}|重复n次或更多次(最低n次)|
|{n,m}|重复n到m次(最少n次,最多m次)|

## 字符类

数字、字母、数字或空白等字符集合有专门对应的元字符,但有些字符集合(自己按照一定格式定义)没有对应的元字符

我们可以在方括号里列出这些字符

例如 `[1357]`匹配`1、3、5、7`中的一个

也可以指定一个范围

例如`[0-9]` 匹配`0、1、2、3、4、5、6、7、8、9`中的一个

## 分支条件

有两种不同的规则,对同一个字符串,满足其中任意一种规则都会被当成匹配

此时我们用`|`把不同的规则分隔开,匹配时，我们从左向右进行匹配,一旦满足了某个分支,就不会再管分支的其他条件了

## 分组

如果想要从一个字符串中匹配若干个格式一样的子串,需要用到分组

可以用小括号来指定分组(子表达式),并且可以为分组指定重复量

## 反义

|代码/语法|说明|
|-----|----------|
|`\W`|匹配任意不是字母、数字、下划线的字符|
|`\S`|匹配任意不是空白字符的字符|
|`\D`|匹配任意非数字的字符|
|`\B`|匹配不是单词开头或结尾的位置|
|`[^x]`|匹配除了x意外的任意字符 |
|`[^aeiou]`|匹配除了qeiou这几个字符以外的任意字符|

## 向后引用

使用小括号指定了一个子表达式后,这个指定的子表达式捕获的内容被用到接下来的匹配中,就需要用到向后引用

未对分组进行命名时(只是用小括号包着),通过`\num`来表示第num个分组匹配的文本

也可以对分组进行命名 语法是 `(?<gName>\w+)` 这是一个匹配任意多个连续的字母、数字、字符串并命名为分组gName的例子

对分组命名的语法还可以表示为`(?'gName'\w+)`,这时在使用的时候需要用`\kgName`的方式来引用前面命名的分组


分组的语法还有很多

<table>
	<th>
		<td>分类</td>
		<td>代码/语法</td>
		<td>说明</td>
	</th>
	<tr>
		<td rowspan="3">捕获</td>
		<td>(exp)</td>
		<td>匹配exp,并捕获文本到自动命名的组里</td>
	</tr>
	<tr>
		<td>(?<name>exp)</td>
		<td>匹配exp,并捕获文本到名称为name的组里,也可以写成(?'name'exp)</td>
	</tr>
	<tr>
		<td>(?:exp)</td>
		<td>匹配exp,不捕获匹配的文本,也不给此组分配组号</td>
	</tr>
	<tr>
		<td rowspan="3">零宽断言</td>
		<td>(?=exp)</td>
		<td>匹配exp前面的位置</td>
	</tr>
	<tr>
		<td>(?<=exp)</td>
		<td>匹配exp后面的位置</td>
	</tr>
	<tr>
		<td>(?!exp)</td>
		<td>匹配后面跟的不是exp的位置</td>
	</tr>
	<tr>
		<td>(?<!exp)</td>
		<td>匹配前面不是exp的位置</td>
	</tr>
	<tr>
		<td>注释</td>
		<td>(?#comment)</td>
		<td>这种类型的分组不对正则表达式的处理产生任何影响,仅用于方便人们阅读</td>
	</tr>
</table>

## 零宽断言

用于指定一个位置,这个位置满足一定的条件(断言),但是却像`\b`,`^`,`$`那样并不会匹配出一个字符,成为零宽断言

`(?=exp)` 零宽度正预测先行断言,它返回一个位置,这个位置后的字符串能够被exp匹配到

`(?<=exp)` 零宽度正回顾后发断言,它返回一个位置,这个位置前的字符串能够被exp匹配到

## 负向零宽断言

`(?!exp)` 零宽度负预测先行断言,返回一个位置,这个位置后面的字符串不能被exp匹配
`(?<!exp)` 零宽度负回顾后发断言,返回一个位置,这个位置前面的字符串不能被exp匹配

## 注释

`(?#comment)` 包含一个注释

## 贪婪匹配和懒惰匹配

正则表达式的正常行为是,使得整个表达式能匹配的前提下,匹配尽可能多的字符,这被称为贪婪匹配

如果我们想让正则表达式在能够匹配到的前提下匹配尽可能少的字符,只需要在表达式的后面加一个`?`,这被称作懒惰匹配


相对应的懒惰限定符

|代码/语法|说明|
|---|----|
|`*?`|重复任意次,但尽可能少重复|
|`+?`|重复1次或更多次,但尽可能少重复|
|`??`|重复0次或者1次,但尽可能少重复|
|`{n,m}?`|重复n到m次,但尽可能少重复|
|`{n,}?`|重复n次以上,但尽可能少重复|
